import pandas as pd
import pygeoj
import numpy as np
from pyproj import Proj, transform
from bokeh.palettes import grey
from bkcharts import Bar, show, defaults, cat
from bokeh.models import GeoJSONDataSource, Circle, Legend, HoverTool, ColumnDataSource
from bokeh.plotting import figure
from bokeh.tile_providers import STAMEN_TERRAIN
from bokeh.models.glyphs import Patches
from collections import OrderedDict

def makeStackedBar(df, x, y, sort_x=False, x_ascending=True, sort_bars=False, bars_col='', bars_agg=None, bars_ascending=True, 
                sort_stacks=False, stacks_col='', stacks_agg=None, stacks_ascending=True, colors=grey, title="title", plot_size=('responsive',)):
    '''
    Parameters
    ----------
    df : str
        Dataframe containing data
    x : str
        Column name for x-axis
    y : str
        Column name for y-axis
    sort_x : boolean
        Boolean whether to sort by x-axis
    x_ascending : boolean
        Boolean to sort x's by ascending
    sort_bars : boolean
        Boolean whether to sort bars
    bars_col : str
        Column name of values of bars 
    bars_agg : function
        Function to apply to aggregation to sort bars by
    bars_ascending : boolean
        Boolean to sort bars ascending
    sort_stacks : boolean
        Boolean whether to sort stacks
    stacks_col : str
        Column name of values for stacks 
    stacks_agg : function
        Function to apply to aggregation to sort stacks by
    stacks_ascending : boolean
        Boolean to sort bars ascending
    colors : color palette
        Pass in a Bokeh color palette
    plot_size : tuple
        Either ('responsive') or (width, height)

    Returns
    -------
    Returns a stacked bar chart object of x by y. The bars and stacks can be
    generated by the passed in aggregation function or directly passed in. The
    sorting will prioritize bars before the x-axis values.
    '''
    # Create bars for stacked bar graph
    if bars_agg:
        bar = df.groupby([x, y]).apply(bars_agg).reset_index()
    elif bars_col:
        bar = df[[x, y, bars_col]]
    else:
        bar = df.groupby([x, y]).size().reset_index()

    bar.columns = [x, y, 'bar_order']
    # Create stacks within each bar for stacked bar graph
    if stacks_agg:
        bar['stack_order'] = (bar.groupby(x)['bar_order']
                                            .transform(stacks_agg))
    elif stacks_col:
        bar['stack_order'] = df[stacks_col]
    else:
        raise ValueError('No values for stacks')

    # Sort bars and stacks if necessary
    sort = []
    ascend = []
    if sort_stacks:
        sort.append('stack_order')
        ascend.append(bars_ascending)
    if sort_bars:
        sort.append('bar_order')
        ascend.append(stacks_ascending)
    if sort_x:
        sort.append(x)
        ascend.append(x_ascending)
    bar = bar.loc[bar.sort_values(sort, ascending=ascend).index]
    unique_vals = bar[y].unique().size

    if plot_size[0] == 'responsive':
        bar_plot = Bar(bar, label=cat(columns=x, sort=False), 
                        palette=colors(unique_vals), values='bar_order', 
                        stack=y, responsive=True, active_scroll='wheel_zoom',
                        title=title)
    elif len(plot_size) == 2:
        bar_plot = Bar(bar, label=cat(columns=x, sort=False), 
                        palette=colors(unique_vals), values='bar_order', 
                        stack=y, active_scroll='wheel_zoom', title=title,
                        plot_width=plot_size[0], plot_height=plot_size[1])
    else:
        raise ValueError('READ THE DOCUMENTATION YOU LAZY FUCK')

    return bar_plot


def makeMap(df, locations, vals, x_ranges=(-20000000, 20000000), 
            y_ranges=(-20000000, 20000000), mintsFile='', path='', ext='.json', 
            map_tile=STAMEN_TERRAIN, palette=grey, colors_ascending=True, 
            pt_size=lambda x: x, title='Production place'):
    '''
    Parameters
    ----------
    df : Pandas dataframe
        Dataframe with data to make map
    locations : str
        Column name of the locations
    vals : str
        Column name of the values for color and size purposes
    x_ranges : tuple
        x-axis range in meters
    y_ranges : tuple
        y-axis range in meters
    mintsFile : str
        Path to the ANS mints file
    path : str
        Path to the geoJSON file
    ext : str
        Extension of the geoJSON files
    map_tile : bokeh tile obj
        Tile to be used under the map
    palette : bokeh palette object
        Color palette to be used
    colors_ascending : boolean
        Boolean wheter colors should ascend the color palette
    pt_size : function
        Function to size the points
    title : str
        String containing title of plot

    Returns
    -------
    Returns a map object
    '''
    # Create dataframe to hold all data for map
    locs = df[locations].unique()
    map_df = pd.DataFrame(columns=['Location', 'Count', 'Color', 'is_point', 
                                    'point_xs', 'point_ys', 'patch_xs', 
                                    'patch_ys', 'Size'], 
                            index=range(len(locs)))
    
    # Create colors list
    colors = palette(len(df[locations].unique()))
    if colors_ascending:
        colors = colors[::-1]

    # Create dictionary of coordinates
    mintLocations = {}
    data = pygeoj.load(mintsFile)
    for feature in data:
        name = feature.properties['name']
        coordinate = feature.geometry.coordinates
        mintLocations[name] = coordinate
        
    # Initialize counter
    row = 0

    # object to convert coordinates from lat/long to meters
    from_proj = Proj(init="epsg:4326")
    to_proj = Proj(init="epsg:3857")

    for loc in locs:  
        point_xs = 0
        point_ys = 0
        patch_xs = []
        patch_ys = []
        is_point = False

        # Get coordinates of the location
        if loc in mintLocations:
            coors = mintLocations[loc]
        else:
            data = pygeoj.load(filepath=path+str(loc)+'.'+ext)
            coors = data[0].geometry.coordinates
        if len(coors) == 2:
            is_point = True
            x, y = transform(from_proj, to_proj, coors[0], coors[1])
            point_xs = x
            point_ys = y
        elif len(coors) == 1:
            for lst in coors[0]:
                x, y = transform(from_proj, to_proj, lst[0], lst[1])
                patch_xs.append(x)
                patch_ys.append(y)
        else:
            for lst in coors:
                for sublst in lst[0]:
                    x, y = transform(from_proj, to_proj, sublst[0], sublst[1])
                    patch_xs.append(x)
                    patch_ys.append(y)

        # Get count of coins produced from location
        count = df[df[locations] == loc][vals].mean()

        # Size of point
        size = pt_size(count)

        # Color of point/patch
        color = colors[np.where(df[vals].unique() == count)[0][0]]

        map_df.iloc[row]['Location'] = loc
        map_df.iloc[row]['Count'] = count
        map_df.iloc[row]['Color'] = color
        map_df.iloc[row]['is_point'] = is_point
        map_df.iloc[row]['point_xs'] = point_xs
        map_df.iloc[row]['point_ys'] = point_ys
        map_df.iloc[row]['Size'] = size
        map_df.iloc[row]['patch_xs'] = patch_xs
        map_df.iloc[row]['patch_ys'] = patch_ys
        row += 1
        
    # Seperate patches and points to seperate dataframes
    df_patches = map_df[map_df['is_point'] == False]
    df_points = map_df[map_df['is_point'] == True]

    # Convert patches and points to Bokeh databases
    source_patches = ColumnDataSource(df_patches)
    source_points = ColumnDataSource(data=df_points)

    # Create points and patches graph objects
    patches = Patches(xs="patch_xs", ys="patch_ys", fill_color="Color",
                          fill_alpha=0.8, line_color="Color", line_width=0.5)
    points = Circle(x="point_xs", y="point_ys", size='Size', 
                    fill_color="Color", fill_alpha=.9)

    # Create plot with map tile
    map_plot = figure(plot_width=1000, plot_height=480,
                               active_scroll='wheel_zoom',
                               x_range=x_ranges, y_range=y_ranges, title=title)
    map_plot.add_tile(map_tile)

    # Add points and patches objects to graph
    map_plot.add_glyph(source_patches, patches)
    map_plot.add_glyph(source_points, points)

    # Add tooltips
    map_plot.add_tools(HoverTool())
    hover = map_plot.select(dict(type=HoverTool))
    hover.tooltips = OrderedDict([
        (locations, '@Location'),
        (vals, '@Count')
        ])
                      
    return map_plot

if __name__ == "__main__":
        import doctest
        doctest.testmod()
